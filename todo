#!/bin/bash

#
# todo
#
# Copyright 2017 Laurent Wandrebeck <l.wandrebeck@quelquesmots.fr>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#

# exit immediately if some command exits with non 0 status which is not taken care of ( || do something )
set -e
# make bash grumble on unset variables.
set -u

repo="https://github.com/lwandrebeck/todo"
version="0.9.4"

version () {
    echo "${version}"
}

usage() {
    echo "Usage: ${0} [option] [argument]

    -a : List All tasks.
    -c rowid : Mark task with rowid as Completed at the moment the command is issued.
    -d rowid : Delete task with rowid from database (no cancel possible).
    -h : This help.
    -i : informations about database.
    -n \"task description\": Create a New task. Creation time is stored at the moment command is issued.
    -s word: Search for not yet completed tasks containing \" word \" (case insensitive search).
    -S word: Search for still valid and completed tasks containing \" word \" (case insensitive search).
    -u rowid: Mark as Unfinished a task previously marked as completed.
    -v: Version.

Your todo database path is stored in ~/.todorc, which defaults to ~/.todo.db

SQLite does provide 4 engines, default (old) one, and FTS (newer) 3, 4 and 5 (Full Text Search).
FTS[345] do provide MATCH capability, which matches on word (space separated), unlike default engine which uses much slower LIKE %word% (*word* as in shell equivalent).
Note that it is highly unlikely your sqlite3 binary is old enough or compiled without FTS (at least 3) support. todo will use FTS3 if available."
}

error () {
    if [ ! -z "${1}" ]
    then
        echo "Something bad happened. command was: \"${1}\""
    else
        echo "Something bad happened."
    fi
    exit 3
}

informations () {
    query="SELECT * FROM info;"
    echo "Your todo database is located at: \"${1}\"
SQL mode used, database creation time, todo version when db was created, SQLite version at db creation."
    "${sqlite3}" -header -column "${TODODB}" "${query}" || { error "informations function: ${query}" ; exit 3 ; }
}

initializedb () {
    now=$(date +"%Y-%m-%d %R:%S")
    sqliteversion="$(${sqlite3} --version)"
    query="CREATE TABLE info(sqlmode TEXT NOT NULL, creation TEXT NOT NULL, todoversion TEXT NOT NULL, sqliteversion TEXT NOT NULL);"
    insert="INSERT INTO info(sqlmode, creation, todoversion, sqliteversion) VALUES ('${ACTUALSQLMODE}', '${now}', '${version}', '${sqliteversion}');"
    case "${ACTUALSQLMODE}" in
        "db"   ) query2="CREATE TABLE todo (title TEXT NOT NULL, creation TEXT NOT NULL, completed TEXT);" ;;
        "fts3" ) query2="CREATE VIRTUAL TABLE todo USING ${ACTUALSQLMODE}(title TEXT NOT NULL, creation TEXT NOT NULL, completed TEXT);" ;;
        *      ) echo "${SQLMODE}" "is not a valid SQLMODE value. That definitively should not have happened. Please report a bug at ${repo}"; exit 2 ;;
    esac
    initializedb_rollback () {
		rm -f "${TODODB}"
		exit 3
	}
	# better no db than a partially initialized one.
	trap initializedb_rollback INT TERM EXIT
    "${sqlite3}" "${TODODB}" "${query}" || { error "initializedb function: ${query}" ; exit 3 ; }
    "${sqlite3}" "${TODODB}" "${insert}" || { error "initializedb function: ${insert}" ; exit 3 ; }
    "${sqlite3}" "${TODODB}" "${query2}" || { error "initializedb function: ${query2}" ; exit 3 ; }
    # get rid of the trap
    trap - INT TERM EXIT
    echo "todo database \"${TODODB}\" successfully created"
}

addentry () {
    now=$(date +"%Y-%m-%d %R:%S")
    query="INSERT INTO todo(title, creation, completed) VALUES('${1}', '${now}', NULL);"
    "${sqlite3}" "${TODODB}" "${query}" || { error "addentry function: ${query}" ; exit 3 ; }
}

completeentry () {
    if [ -z "${1}" ]
    then
        usage
    else
        declare -i id
        id="${1}"
        if [ "${id}" != "${1}" ]
        then
            #id is not numeric
            usage
        else
            now=$(date +"%Y-%m-%d %R:%S")
            query="UPDATE todo SET completed='${now}' WHERE rowid=${id};"
            "${sqlite3}" "${TODODB}" "${query}" || { error "completeentry function: ${query}" ; exit 3 ; }
        fi
    fi
}

unfinishentry () {
    if [ -z "${1}" ]
    then
        usage
    else
        declare -i id
        id="${1}"
        if [ "${id}" != "${1}" ]
        then
            #id is not numeric
            usage
        else
            query="UPDATE todo SET completed=NULL WHERE rowid=${id};"
            "${sqlite3}" "${TODODB}" "${query}" || { error "unfinishentry function: ${query}" ; exit 3 ; }
        fi
    fi
}

deleteentry () {
    if [ -z "${1}" ]
    then
        usage
    else
        declare -i id
        id="${1}"
        if [ "${id}" != "${1}" ]
        then
            #id is not numeric
            usage
        else
            query="DELETE FROM todo WHERE rowid=${id};"
            "${sqlite3}" "${TODODB}" "${query}" || { error "deleteentry function: ${query}" ; exit 3 ; }
        fi
    fi
}

listentries () {
    query="SELECT rowid, title, creation FROM todo WHERE completed IS NULL;"
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null  || { error "listentries function: ${query}" ; exit 3 ; }
}

listallentries () {
    query="SELECT rowid, title, creation, completed FROM todo;"
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null || { error "listallentries function: ${query}" ; exit 3 ; }
}

search () {
    if [ ! -z "${1}" ]
    then
        case "${SQLMODE}" in
            "db"   ) query="SELECT rowid, title, creation FROM todo WHERE completed IS NULL AND title LIKE '%${1}%';" ;;
            "fts3" ) query="SELECT rowid, title, creation FROM todo WHERE completed IS NULL AND title MATCH '${1}';" ;;
            *      ) echo "${SQLMODE}" "is not a valid SQLMODE value. That definitively should not have happened. Please report a bug at ${repo}"; exit 2 ;;
        esac
    else
        usage
    fi
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null || { error "search function: ${query}" ; exit 3 ; }
}

searchall () {
    if [ ! -z "${1}" ]
    then
        case "${SQLMODE}" in
            "db"   ) query="SELECT rowid, title, creation, completed FROM todo WHERE title LIKE '%${1}%';" ;;
            "fts3" ) query="SELECT rowid, title, creation, completed FROM todo WHERE title MATCH '${1}';" ;;
            *      ) echo "${SQLMODE}" "is not a valid SQLMODE value. That definitively should not have happened. Please report a bug at ${repo}"; exit 2 ;;
        esac
    else
        usage
    fi
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null || { error "searchall function: ${query}" ; exit 3 ; }
}

todorc () {
    # create default ~/.todorc file if it does not exist.
    TODORC="${HOME}/.todorc"
    if [ ! -f "${TODORC}" ]
    then
        echo "It looks like this is the first time you run todo. We hope you will like it"
        echo "Would you like to tweak todo database path ? (hit enter to keep default value (~/.todo.db), or give (potentially non-existing) dir) :"
        read -p "enter dir $ " tododb
        # user did not type anything
        if [ -z "${tododb}" ]
        then
            TODODB="${HOME}/.todo.db"
        else
            # that directory does not exist
            if [ ! -d "${tododb}" ]
            then
                mkdir -p "${tododb}" || { error "todorc function: mkdir -p \"${tododb}\"" ; exit 5 ; }
            else
                #let’s assure we can write into the existing directory
                if [ ! -w "${tododb}" ]
                then
                    echo "todorc function: Error: \"${tododb}\" is not writable, we can’t store database there."
                    exit 6
                else
                    TODODB="${tododb}/.todo.db"
                fi
            fi
        fi
        todorc_rollback () {
			rm -f "${TODORC}"
			exit
		}
		# better no .todorc than an incomplete one
        trap todorc_rollback INT TERM EXIT
        echo "TODODB=\"${TODODB}\"" >> "${TODORC}"
        echo "SQLITEOPTS=\"-header -column -init ${TODOSQLITERC}\"" >> "${TODORC}"
        # get rid of the trap
        trap - INT TERM EXIT
        echo "${TODORC} successfully created."
    fi
    source "${TODORC}"
}

todosqliterc () {
    TODOSQLITERC="${HOME}/.todosqliterc"
    if [ ! -f "${TODOSQLITERC}" ]
    then
		todosqliterc_rollback () {
			rm -f "${TODOSQLITERC}"
			exit
		}
		# better no .todosqliterc than an incomplete one
		trap todosqliterc_rollback INT TERM EXIT
        echo ".width 5 83 19 19" > "${TODOSQLITERC}"
        # get rid of the trap
        trap - INT TERM EXIT
        echo "${TODOSQLITERC} successfully created."
    fi
}

sqlite3checks () {
    #verify if sqlite3 command is available
    sqlite3="$(which sqlite3)"
    which sqlite3 &> /dev/null || unset sqlite3
    if [ -z "${sqlite3}" ]
    then
        echo "${0} needs sqlite3 command to run, please install it."
        exit 1
    fi
    # test if FTS is available
    ACTUALSQLMODE="fts3"
    tmp="$(mktemp)"
    "${sqlite3}" "${tmp}" "CREATE VIRTUAL TABLE test USING ${ACTUALSQLMODE}(title TEXT NOT NULL);" 2> /dev/null || ACTUALSQLMODE="db"
    # prevent remaining tmp file if todo is interrupted
    trap "rm -f '${tmp}' ; exit " INT TERM EXIT
    rm -f "${tmp}"
}

dbchecks () {
    if [ ! -f "${TODODB}" ]
    then
        echo "todo database not found, creating it…"
        initializedb
    else
        SQLMODE=$(${sqlite3} ${TODODB} "SELECT sqlmode FROM info;")
        # we’ve got a fts3 database and sqlite3 is so old it can’t manage it.
        if [ "${SQLMODE}" == "fts3" ] && [ "${ACTUALSQLMODE}" == "db" ]
        then
            echo "Sorry, your todo database ${TODODB} uses FTS3 format, which your ${sqlite3} binary does not support. Exiting."
            exit 4
        fi
    fi
}

todosqliterc
todorc
sqlite3checks
dbchecks

#satisfy set -u
args=${1:-}
if [ -z "${args}" ]
then
    listentries
else
    if ( ! getopts ac:d:hin:s:S:u:v OPT )
    then
        usage
        exit 1
    fi
fi

while getopts ac:d:hin:s:S:u:v OPT;
do
    case $OPT in
        a) listallentries ;;
        c) completeentry "$OPTARG" ;;
        d) deleteentry "$OPTARG" ;;
        h) usage ;;
        i) informations "${TODODB}" ;;
        n) addentry "$OPTARG" ;;
        s) search "$OPTARG" ;;
        S) searchall "$OPTARG" ;;
        u) unfinishentry "$OPTARG" ;;
        v) version ;;
        \?) usage
            exit ;;
        :) echo "Missing argument for $OPT"
           usage
           exit ;;
    esac
done
