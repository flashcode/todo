#!/bin/bash

#
# todo
#
# Copyright 2017 Laurent Wandrebeck <l.wandrebeck@quelquesmots.fr>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA 02110-1301, USA.
#

repo="https://github.com/lwandrebeck/todo"
version="0.9.2"

version () {
    echo "${version}"
}

usage() {
    echo "Usage: ${0} [option] [argument]

    -a : List All tasks.
    -c rowid : Mark task with rowid as Completed at the moment the command is issued.
    -d rowid : Delete task with rowid from database (no cancel possible).
    -h : This help.
    -i : informations about database.
    -n \"task description\": Create a New task. Creation time is stored at the moment command is issued.
    -s word: Search for not yet completed tasks containing \" word \" (case insensitive search).
    -S word: Search for still valid and completed tasks containing \" word \" (case insensitive search).
    -u rowid: Mark as Unfinished a task previously marked as completed.
    -v: Version.

Your todo database path is stored in ~/.todorc, which defaults to ~/.todo.db

SQLite does provide 4 engines, default (old) one, and FTS (newer) 3, 4 and 5 (Full Text Search).
FTS[345] do provide MATCH capability, which matches on word (space separated), unlike default engine which uses much slower LIKE %word% (*word* as in shell equivalent).
Note that it is highly unlikely your sqlite3 binary is old enough or compiled without FTS (at least 3) support. todo will use FTS3 if available."
}

error () {
    if [ ! -z "${1}" ]
    then
        echo "Something bad happened. SQL query was: ${1}"
    else
        echo "Something bad happened."
    fi
    exit 3
}

informations () {
    query="SELECT * FROM info;"
    echo "Your todo database is located at: ${TODOBD}
SQL mode used, database creation time, todo version when db was created, SQLite version at db creation."
    "${sqlite3}" -header -column "${TODODB}" "${query}" || error "${query}"
}

initializedb () {
    now=$(date +"%Y-%m-%d %R:%S")
    sqliteversion="$(${sqlite3} --version)"
    query="CREATE TABLE info(sqlmode TEXT NOT NULL, creation TEXT NOT NULL, todoversion TEXT NOT NULL, sqliteversion TEXT NOT NULL);"
    insert="INSERT INTO info(sqlmode, creation, todoversion, sqliteversion) VALUES ('${ACTUALSQLMODE}', '${now}', '${version}', '${sqliteversion}');"
    case "${ACTUALSQLMODE}" in
        "db"   ) query2="CREATE TABLE todo (title TEXT NOT NULL, creation TEXT NOT NULL, completed TEXT);" ;;
        "fts3" ) query2="CREATE VIRTUAL TABLE todo USING ${ACTUALSQLMODE}(title TEXT NOT NULL, creation TEXT NOT NULL, completed TEXT);" ;;
        *      ) echo "${SQLMODE}" "is not a valid SQLMODE value. That definitively should not have happened. Please report a bug at ${repo}"; exit 2 ;;
    esac
    echo "todo database creation"
    "${sqlite3}" "${TODODB}" "${query}" || error "${query}"
    "${sqlite3}" "${TODODB}" "${insert}" || error "${insert}"
    "${sqlite3}" "${TODODB}" "${query2}" || error "${query2}"
}

addentry () {
    now=$(date +"%Y-%m-%d %R:%S")
    query="INSERT INTO todo(title, creation, completed) VALUES('${1}', '${now}', NULL);"
    "${sqlite3}" "${TODODB}" "${query}" || error "${query}"
}

completeentry () {
    if [ -z "${1}" ]
    then
        usage
    else
        declare -i id
        id="${1}"
        if [ "${id}" != "${1}" ]
        then
            #id is not numeric
            usage
        else
            now=$(date +"%Y-%m-%d %R:%S")
            query="UPDATE todo SET completed='${now}' WHERE rowid=${id};"
            "${sqlite3}" "${TODODB}" "${query}" || error "${query}"
        fi
    fi
}

unfinishentry () {
    if [ -z "${1}" ]
    then
        usage
    else
        declare -i id
        id="${1}"
        if [ "${id}" != "${1}" ]
        then
            #id is not numeric
            usage
        else
            query="UPDATE todo SET completed=NULL WHERE rowid=${id};"
            "${sqlite3}" "${TODODB}" "${query}" || error "${query}"
        fi
    fi
}

deleteentry () {
    if [ -z "${1}" ]
    then
        usage
    else
        declare -i id
        id="${1}"
        if [ "${id}" != "${1}" ]
        then
            #id is not numeric
            usage
        else
            query="DELETE FROM todo WHERE rowid=${id};"
            "${sqlite3}" "${TODODB}" "${query}" || error "${query}"
        fi
    fi
}

listentries () {
    query="SELECT rowid, title, creation FROM todo WHERE completed IS NULL;"
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null  || error "${query}"
}

listallentries () {
    query="SELECT rowid, title, creation, completed FROM todo;"
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null || error "${query}"
}

search () {
    if [ ! -z "${1}" ]
    then
        case "${SQLMODE}" in
            "db"   ) query="SELECT rowid, title, creation FROM todo WHERE completed IS NULL AND title LIKE '%${1}%';" ;;
            "fts3" ) query="SELECT rowid, title, creation FROM todo WHERE completed IS NULL AND title MATCH '${1}';" ;;
            *      ) echo "${SQLMODE}" "is not a valid SQLMODE value. That definitively should not have happened. Please report a bug at ${repo}"; exit 2;;
        esac
    else
        usage
    fi
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null || error "${query}"
}

searchall () {
    if [ ! -z "${1}" ]
    then
        case "${SQLMODE}" in
            "db"   ) query="SELECT rowid, title, creation, completed FROM todo WHERE title LIKE '%${1}%';" ;;
            "fts3" ) query="SELECT rowid, title, creation, completed FROM todo WHERE title MATCH '${1}';" ;;
            *      ) echo "${SQLMODE}" "is not a valid SQLMODE value. That definitively should not have happened. Please report a bug at ${repo}"; exit 2;;
        esac
    else
        usage
    fi
    "${sqlite3}" ${SQLITEOPTS} "${TODODB}" "${query}" 2> /dev/null || error "${query}"
}

todorc () {
    # create default ~/.todorc file if it does not exist.
    TODORC="${HOME}/.todorc"
    if [ ! -f "${TODORC}" ]
    then
        echo "TODODB=\"${HOME}/.todo.db\"" >> "${TODORC}"
        echo "SQLITEOPTS=\"-header -column -init ${TODOSQLITERC}\"" >> "${TODORC}"
        echo "${TODORC} created."
    fi
    . "${TODORC}"
}

todosqliterc () {
    TODOSQLITERC="${HOME}/.todosqliterc"
    if [ ! -f "${TODOSQLITERC}" ]
    then
        echo ".width 5 83 19 19" > "${TODOSQLITERC}"
        echo "${TODOSQLITERC} created."
    fi
}

sqlite3checks () {
    #verify if sqlite3 command is available
    sqlite3="$(which sqlite3)"
    which sqlite3 &> /dev/null || unset sqlite3
    if [ -z "${sqlite3}" ]
    then
        echo "${0} needs sqlite3 command to run, please install it."
        exit 1
    fi
    # test if FTS is available
    ACTUALSQLMODE="fts3"
    "${sqlite3}" "/tmp/.tmp.db" "CREATE VIRTUAL TABLE test USING ${ACTUALSQLMODE}(title TEXT NOT NULL);" 2> /dev/null || ACTUALSQLMODE="db"
    rm -f "/tmp/.tmp.db"
}

dbchecks () {
    if [ ! -f "${TODODB}" ]
    then
        echo "todo database not found, creating it…"
        initializedb
    else
        SQLMODE=$(${sqlite3} ${TODODB} "SELECT sqlmode FROM info;")
        # we’ve got a fts3 database and sqlite3 is so old it can’t manage it.
        if [ "${SQLMODE}" == "fts3" ] && [ "${ACTUALSQLMODE}" == "db" ]
        then
            echo "Sorry, your todo database ${TODODB} uses FTS3 format, which your ${sqlite3} binary does not support. Exiting."
            exit 1
        fi
    fi
}

todosqliterc
todorc
sqlite3checks
dbchecks

if [ -z "${1}" ]
then
    listentries
else
    if ( ! getopts ac:d:hin:s:S:u:v OPT )
    then
        usage
        exit 1
    fi
fi

while getopts ac:d:hin:s:S:u:v OPT;
do
    case $OPT in
        a) listallentries ;;
        c) completeentry "$OPTARG" ;;
        d) deleteentry "$OPTARG" ;;
        h) usage ;;
        i) informations ;;
        n) addentry "$OPTARG" ;;
        s) search "$OPTARG" ;;
        S) searchall "$OPTARG" ;;
        u) unfinishentry "$OPTARG" ;;
        v) version ;;
        \?) usage
            exit ;;
        :) echo "Missing argument for $OPT"
           usage
           exit ;;
    esac
done
